// Generated by CoffeeScript 1.4.0
(function() {
  var DBConnect, PostgresDriver, Schema, postgres, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  postgres = require('pg');

  DBConnect = require('./dbconnect');

  _ = require('underscore');

  Schema = require('./schema');

  PostgresDriver = (function(_super) {

    __extends(PostgresDriver, _super);

    function PostgresDriver() {
      return PostgresDriver.__super__.constructor.apply(this, arguments);
    }

    PostgresDriver.defaultOptions = {
      host: 'localhost',
      port: 5432,
      database: 'postgres'
    };

    PostgresDriver.prototype.connString = function() {
      var database, host, password, port, user, _ref;
      _ref = this.args, user = _ref.user, password = _ref.password, host = _ref.host, port = _ref.port, database = _ref.database;
      if (user && password) {
        return "postgres://" + user + ":" + password + "@" + host + ":" + port + "/" + database;
      } else {
        return "postgres://" + host + ":" + port + "/" + database;
      }
    };

    PostgresDriver.prototype.tableName = function(name) {
      return name.toLowerCase();
    };

    PostgresDriver.prototype.connect = function(cb) {
      var _this = this;
      return postgres.connect(this.connString(), function(err, client, done) {
        if (err) {
          return cb(err);
        } else {
          _this.inner = client;
          _this.done = done;
          return cb(null, _this);
        }
      });
    };

    PostgresDriver.prototype._query = function(stmt, args, cb) {
      var _ref;
      _ref = this.parseStmt(stmt, args), stmt = _ref.stmt, args = _ref.args;
      return this.inner.query(stmt, args, cb);
    };

    PostgresDriver.prototype.parseStmt = function(stmt, args) {
      var i, matched, normalized, normedArgs, s, splitted, _i, _len;
      splitted = stmt.split(/(\$[\w]+)/);
      i = 1;
      normalized = [];
      normedArgs = [];
      for (_i = 0, _len = splitted.length; _i < _len; _i++) {
        s = splitted[_i];
        matched = s.match(/^\$([\w]+)$/);
        if (matched) {
          if (!args.hasOwnProperty(matched[1])) {
            throw new Error("Postgresql.query:stmt_missing_key: " + s);
          }
          normedArgs.push(args[matched[1]]);
          normalized.push("$" + (i++));
        } else {
          normalized.push(s);
        }
      }
      return {
        stmt: normalized.join(''),
        args: normedArgs
      };
    };

    PostgresDriver.prototype.disconnect = function(cb) {
      try {
        this.done();
        return cb(null);
      } catch (e) {
        return cb(e);
      }
    };

    PostgresDriver.prototype.ensureColumns = function(table, kv) {
      var key, val, _results;
      _results = [];
      for (key in kv) {
        val = kv[key];
        if (!table.hasColumn(key)) {
          throw new Error("Postgresql.insert.unknown_column: " + key);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    PostgresDriver.prototype.generateInsert = function(table, args) {
      var columnText, i, key, keys, phText, val, vals;
      if (args instanceof Array) {
        throw new Error("Postgresql.insert:multi_insert_not_yet_supported: " + args);
      } else {
        args = table.make(args);
        this.ensureColumns(table, args);
      }
      keys = [];
      vals = [];
      for (key in args) {
        val = args[key];
        keys.push(key);
        vals.push(val);
      }
      columnText = keys.join(', ');
      phText = ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = vals.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push("$" + i);
        }
        return _results;
      })()).join(', ');
      return {
        stmt: "insert into " + table.name + " (" + columnText + ") select " + phText,
        args: vals
      };
    };

    PostgresDriver.prototype.criteriaQuery = function(query, sep, i) {
      var criteria, keys, val, vals;
      if (sep == null) {
        sep = ' and ';
      }
      if (i == null) {
        i = 1;
      }
      criteria = [];
      vals = [];
      for (keys in args) {
        val = args[keys];
        criteria.push("" + key + " = $" + (i++));
        vals.push(val);
      }
      return {
        stmt: criteria.join(sep),
        args: vals
      };
    };

    PostgresDriver.prototype.generateDelete = function(table, query) {
      var args, stmt, _ref;
      this.ensureColumns(table, query);
      _ref = this.criteriaQuery(query), stmt = _ref.stmt, args = _ref.args;
      if (args.length === 0) {
        return {
          stmt: "delete from " + table.name,
          args: args
        };
      } else {
        return {
          stmt: "delete from " + table.name + " where " + stmt,
          args: args
        };
      }
    };

    PostgresDriver.prototype.generateSelect = function(table, query) {
      var args, stmt, _ref;
      this.ensureColumns(table, query);
      _ref = this.criteriaQuery(query), stmt = _ref.stmt, args = _ref.args;
      if (args.length === 0) {
        return {
          stmt: "select * from " + table.name,
          args: args
        };
      } else {
        return {
          stmt: "select * from " + table.name + " where " + stmt,
          args: args
        };
      }
    };

    PostgresDriver.prototype.generateUpdate = function(table, setExp, query) {
      var queryGen, setGen;
      this.ensureColumns(table, setExp);
      this.ensureColumsn(table, query);
      setGen = this.criteriaQuery(query, ', ');
      queryGen = this.criteriaQuery(query, ' and ', setGen.args.length + 1);
      if (queryGen.args.length === 0) {
        return {
          stmt: "update " + table.name + " set " + setGen.stmt,
          args: setGen.args
        };
      } else {
        return {
          stmt: "update " + table.name + " set " + setGen.stmt + " where " + queryGen.stmt,
          args: setGen.args.concat(queryGen.args)
        };
      }
    };

    return PostgresDriver;

  })(DBConnect);

  DBConnect.register('postgres', PostgresDriver);

  module.exports = PostgresDriver;

}).call(this);
