// Generated by CoffeeScript 1.4.0
(function() {
  var DBConnect, PostgresDriver, Schema, postgres, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  postgres = require('pg');

  DBConnect = require('./dbconnect');

  _ = require('underscore');

  Schema = require('./schema');

  PostgresDriver = (function(_super) {

    __extends(PostgresDriver, _super);

    function PostgresDriver() {
      return PostgresDriver.__super__.constructor.apply(this, arguments);
    }

    PostgresDriver.defaultOptions = {
      host: 'localhost',
      port: 5432,
      database: 'postgres'
    };

    PostgresDriver.prototype.connString = function() {
      var database, host, password, port, user, _ref;
      _ref = this.args, user = _ref.user, password = _ref.password, host = _ref.host, port = _ref.port, database = _ref.database;
      if (user && password) {
        return "postgres://" + user + ":" + password + "@" + host + ":" + port + "/" + database;
      } else {
        return "postgres://" + host + ":" + port + "/" + database;
      }
    };

    PostgresDriver.prototype.tableName = function(name) {
      var i, normalized, splitted, str;
      splitted = name.split(/([A-Z]+)/);
      i = 0;
      normalized = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = splitted.length; _i < _len; _i++) {
          str = splitted[_i];
          if (str.match(/[A-Z]+/)) {
            if (i++ === 0) {
              _results.push(str.toLowerCase());
            } else {
              _results.push("_" + str.toLowerCase());
            }
          } else {
            _results.push(str);
          }
        }
        return _results;
      })();
      return normalized.join('') + "_t";
    };

    PostgresDriver.prototype.connect = function(cb) {
      var _this = this;
      return postgres.connect(this.connString(), function(err, client, done) {
        if (err) {
          return cb(err);
        } else {
          _this.inner = client;
          _this.done = done;
          return cb(null, _this);
        }
      });
    };

    PostgresDriver.prototype._query = function(stmt, args, cb) {
      var parsed,
        _this = this;
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      parsed = this.parseStmt(stmt, args);
      console.log('Postgres._query', parsed.stmt, parsed.args);
      return this.inner.query(parsed.stmt, parsed.args, function(err, res) {
        if (err) {
          return cb(err);
        } else if (stmt.selectOne) {
          return cb(null, res.rows[0]);
        } else if (stmt.next) {
          return _this._query(stmt.next, {}, cb);
        } else {
          return cb(null, res.rows);
        }
      });
    };

    PostgresDriver.prototype.parseStmt = function(stmt, args) {
      var i, matched, normalized, normedArgs, s, splitted, _i, _len, _ref;
      if (stmt instanceof Object && stmt.stmt && stmt.args) {
        _ref = stmt, stmt = _ref.stmt, args = _ref.args;
      }
      splitted = stmt.split(/(\$[\w]+)/);
      i = 1;
      normalized = [];
      normedArgs = [];
      for (_i = 0, _len = splitted.length; _i < _len; _i++) {
        s = splitted[_i];
        matched = s.match(/^\$([\w]+)$/);
        if (matched) {
          if (!args.hasOwnProperty(matched[1])) {
            throw new Error("Postgresql.query:stmt_missing_key: " + s);
          }
          normedArgs.push(args[matched[1]]);
          normalized.push("$" + (i++));
        } else {
          normalized.push(s);
        }
      }
      return {
        stmt: normalized.join(''),
        args: normedArgs
      };
    };

    PostgresDriver.prototype.disconnect = function(cb) {
      try {
        this.done();
        return cb(null);
      } catch (e) {
        return cb(e);
      }
    };

    PostgresDriver.prototype.beginTrans = function(cb) {
      return this._query('begin', {}, cb);
    };

    PostgresDriver.prototype.commit = function(cb) {
      return this._query('commit', {}, cb);
    };

    PostgresDriver.prototype.rollback = function(cb) {
      return this._query('rollback', {}, cb);
    };

    PostgresDriver.prototype.ensureColumns = function(table, kv) {
      var key, val, _results;
      _results = [];
      for (key in kv) {
        val = kv[key];
        if (!table.hasColumn(key)) {
          throw new Error("Postgresql.insert.unknown_column: " + key);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    PostgresDriver.prototype.generateInsert = function(table, args) {
      var columnText, idQuery, key, keys, phText, select, val;
      if (args instanceof Array) {
        throw new Error("Postgresql.insert:multi_insert_not_yet_supported: " + args);
      } else {
        args = table.make(args);
        this.ensureColumns(table, args);
      }
      keys = [];
      for (key in args) {
        val = args[key];
        keys.push(key);
      }
      columnText = keys.join(', ');
      phText = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          _results.push("$" + key);
        }
        return _results;
      })()).join(', ');
      idQuery = table.idQuery(args);
      select = this.generateSelectOne(table, idQuery);
      return {
        stmt: "insert into " + (this.tableName(table.name)) + " (" + columnText + ") select " + phText,
        args: args,
        next: select
      };
    };

    PostgresDriver.prototype.escapeVal = function(val) {
      var strHelper;
      strHelper = function(val) {
        return "'" + val.replace(/\'/g, "''") + "'";
      };
      if (typeof val === 'number') {
        return "" + val;
      } else if (typeof val === 'string') {
        return strHelper(val);
      } else {
        return strHelper(val.toString());
      }
    };

    PostgresDriver.prototype.criteriaQuery = function(query, sep) {
      var criteria, key, v, val;
      if (sep == null) {
        sep = ' and ';
      }
      criteria = [];
      for (key in query) {
        val = query[key];
        if (val instanceof Array) {
          criteria.push("" + key + " in (" + (((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = val.length; _i < _len; _i++) {
              v = val[_i];
              _results.push(this.escapeVal(v));
            }
            return _results;
          }).call(this)).join(', ')) + ")");
        } else {
          criteria.push("" + key + " = $" + key);
        }
      }
      return criteria.join(sep);
    };

    PostgresDriver.prototype.generateDelete = function(table, query) {
      var stmt;
      if (Object.keys(query).length === 0) {
        return {
          stmt: "delete from " + (this.tableName(table.name)),
          args: query
        };
      } else {
        this.ensureColumns(table, query);
        stmt = this.criteriaQuery(query);
        return {
          stmt: "delete from " + (this.tableName(table.name)) + " where " + stmt,
          args: query
        };
      }
    };

    PostgresDriver.prototype.generateSelect = function(table, query) {
      var stmt;
      if (Object.keys(query).length === 0) {
        return {
          stmt: "select * from " + (this.tableName(table.name)),
          args: query
        };
      } else {
        this.ensureColumns(table, query);
        stmt = this.criteriaQuery(query);
        return {
          stmt: "select * from " + (this.tableName(table.name)) + " where " + stmt,
          args: query
        };
      }
    };

    PostgresDriver.prototype.generateSelectOne = function(table, query) {
      var stmt;
      if (Object.keys(query).length === 0) {
        return {
          stmt: "select * from " + (this.tableName(table.name)),
          args: query,
          selectOne: true
        };
      } else {
        this.ensureColumns(table, query);
        stmt = this.criteriaQuery(query);
        return {
          stmt: "select * from " + (this.tableName(table.name)) + " where " + stmt,
          args: query,
          selectOne: true
        };
      }
    };

    PostgresDriver.prototype.generateUpdate = function(table, setExp, query) {
      var queryGen, setGen;
      this.ensureColumns(table, setExp);
      setGen = this.criteriaQuery(setExp, ', ');
      if (Object.keys(query).length === 0) {
        return {
          stmt: "update " + (this.tableName(table.name)) + " set " + setGen,
          args: setExp
        };
      } else {
        this.ensureColumns(table, query);
        queryGen = this.criteriaQuery(query);
        return {
          stmt: "update " + (this.tableName(table.name)) + " set " + setGen + " where " + queryGen,
          args: _.extend({}, setExp, query)
        };
      }
    };

    PostgresDriver.prototype.normalizeRecord = function(table, rec) {
      var col, lc, obj, _i, _len, _ref;
      console.log('PostgresDriver.normalizeRecord', table.name, rec);
      obj = {};
      _ref = table.columns;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        col = _ref[_i];
        lc = col.name.toLowerCase();
        console.log('PostgresDriver.normalize', col.name, lc, rec[lc]);
        if (rec.hasOwnProperty(col.name)) {
          obj[col.name] = rec[col.name];
        } else if (rec.hasOwnProperty(lc)) {
          obj[col.name] = rec[lc];
        } else {
          throw new Error("PostgresDriver.normalizeRecord:unknown_column: " + col.name);
        }
      }
      return obj;
    };

    PostgresDriver.prototype.prepareSpecial = function(key, val) {
      if (typeof val === 'string') {
        return this.prepare(key, function(args, cb) {
          return this.query(val, args, cb);
        });
      } else {
        throw new Error("PostgresDriver.prepareSpecial:unsupported_query_type: " + val);
      }
    };

    PostgresDriver.prototype.supports = function(key) {
      if (key === 'in') {
        return true;
      } else {
        return false;
      }
    };

    return PostgresDriver;

  })(DBConnect);

  DBConnect.register('postgres', PostgresDriver);

  module.exports = PostgresDriver;

}).call(this);
