// Generated by CoffeeScript 1.4.0
(function() {
  var ActiveRecord, ActiveRecordSet, Column, Columns, DATETIME, EMAIL, EventEmitter, HEXSTRING, INTEGER, Index, NUMBER, Reference, STRING, Schema, Table, UUID, async, b2h, check, crypto, h2b, i, sanitize, toHex, uuid, _, _i, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  _ = require('underscore');

  uuid = require('node-uuid');

  async = require('async');

  EventEmitter = require('events').EventEmitter;

  _ref = require('validator'), check = _ref.check, sanitize = _ref.sanitize;

  crypto = require('crypto');

  Column = (function() {

    function Column(table, def) {
      var col, optional, schemaType, type, _ref1;
      this.table = table;
      this.def = def;
      _ref1 = this.def, col = _ref1.col, type = _ref1.type, optional = _ref1.optional;
      this.name = col;
      schemaType = this.table.schema.hasType(type);
      if (!schemaType) {
        throw new Error("unknown_type: " + type);
      }
      this.type = schemaType;
      this.optional = optional || false;
      if (this.def["default"]) {
        this["default"] = this.setupDefault(this.def["default"]);
        this.optional = true;
      }
      if (this.def.update) {
        this.update = this.setupDefault(this.def.update);
      }
    }

    Column.prototype.setupDefault = function(spec) {
      var args, proc,
        _this = this;
      if (spec instanceof Object) {
        proc = this.table.schema.hasFunction(spec.proc);
        if (!proc) {
          throw new Error("unknown_default_function: " + spec.proc);
        }
        if (spec.args instanceof Array) {
          args = spec.args;
          return function(v) {
            return proc.apply(null, args);
          };
        } else {
          return function(v) {
            if (arguments.length > 0) {
              return proc.apply(null, arguments);
            } else {
              return proc();
            }
          };
        }
      } else {
        return function() {
          return spec;
        };
      }
    };

    Column.prototype.destroy = function() {
      delete this.table;
      delete this.type;
      return delete this["default"];
    };

    Column.prototype.serialize = function() {
      return this.def;
    };

    Column.prototype.validate = function(val) {
      if (val !== void 0 && val !== null) {
        return this.type.convertable(val);
      } else if (this.optional) {
        return true;
      } else {
        throw new Error("value_required: " + this.table.name + "." + this.name);
      }
    };

    Column.prototype.make = function(val) {
      if (val !== void 0 && val !== null) {
        return this.type.make(val);
      } else if (this.optional) {
        if (this["default"]) {
          return this["default"]();
        } else {
          return null;
        }
      } else {
        throw new Error("value_required: " + this.table.name + "." + this.name);
      }
    };

    return Column;

  })();

  Columns = (function(_super) {

    __extends(Columns, _super);

    function Columns(columns) {
      var col, _i, _j, _len, _len1;
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        this.ensureColumn(col);
      }
      for (_j = 0, _len1 = columns.length; _j < _len1; _j++) {
        col = columns[_j];
        this.push(col);
        this[col.name] = col;
      }
    }

    Columns.prototype.destroy = function() {
      var key, val, _results;
      _results = [];
      for (key in this) {
        val = this[key];
        if (val instanceof Index) {
          _results.push(val.destroy());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Columns.prototype.ensureColumn = function(col) {
      if (!(col instanceof Column)) {
        throw new Error("columns.ctor:not_a_column: " + col);
      }
    };

    Columns.prototype.splice = function() {
      var col, index, inserted, removed, removedCols, _i, _j, _k, _len, _len1, _len2;
      index = arguments[0], removed = arguments[1], inserted = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      for (_i = 0, _len = inserted.length; _i < _len; _i++) {
        col = inserted[_i];
        this.ensureColumn(col);
      }
      removedCols = Columns.__super__.splice.apply(this, [index, removed].concat(__slice.call(inserted)));
      for (_j = 0, _len1 = removedCols.length; _j < _len1; _j++) {
        col = removedCols[_j];
        delete this[col.name];
      }
      for (_k = 0, _len2 = inserted.length; _k < _len2; _k++) {
        col = inserted[_k];
        this[col.name] = col;
      }
      return removedCols;
    };

    Columns.prototype.push = function() {
      var col;
      col = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.splice.apply(this, [this.length, 0].concat(__slice.call(col)));
    };

    Columns.prototype.pop = function() {
      var col, res;
      col = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      res = this.splice(this.length - 1, 1);
      return res[0];
    };

    Columns.prototype.unshift = function() {
      var col;
      col = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.splice.apply(this, [0, 0].concat(__slice.call(col)));
    };

    Columns.prototype.shift = function() {
      var res;
      res = this.splice(0, 1);
      return res[0];
    };

    return Columns;

  })(Array);

  Reference = (function() {

    function Reference(schema, index, table, columns) {
      this.schema = schema;
      this.index = index;
      this.table = table;
      this.columns = columns;
    }

    return Reference;

  })();

  Index = (function() {

    function Index(table, args) {
      var index, name, primary, reference, unique;
      this.table = table;
      index = args.index, primary = args.primary, unique = args.unique, name = args.name, reference = args.reference;
      if (primary) {
        this.init(primary, name);
        this.ensurePrimary();
      } else if (unique) {
        this.init(unique, name);
        this.ensureUnique();
      } else {
        this.init(index, name);
      }
      if (reference) {
        this.ensureReference(reference);
      }
    }

    Index.prototype.destroy = function() {
      return delete this.table;
    };

    Index.prototype.init = function(columns, name) {
      var col, _i, _len;
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        if (!this.table.hasColumn(col)) {
          throw new Error("unknown_column_in_table: " + col + ", " + this.table.name);
        }
      }
      this.columns = columns;
      this.name = (!name ? this.makeName() : name);
      return this.table.schema.registerIndex(this);
    };

    Index.prototype.makeName = function() {
      var columnName;
      columnName = this.columns.join('_');
      return "" + this.table.name + "_" + columnName;
    };

    Index.prototype.ensurePrimary = function() {
      return this.table.setPrimary(this);
    };

    Index.prototype.ensureUnique = function() {
      return this.unique = true;
    };

    Index.prototype.ensureReference = function(reference) {
      var col, columns, refTable, table, _i, _len, _ref1;
      this.reference = reference;
      _ref1 = this.reference, table = _ref1.table, columns = _ref1.columns;
      refTable = this.table.schema.hasTable(table);
      if (!refTable) {
        throw new Error("Unknown_reference_table: " + table);
      }
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        if (!refTable.hasColumn(col)) {
          throw new Error("unknown_reference_column: " + table + "." + col);
        }
      }
      return this.table.schema.registerReference(this, refTable, columns);
    };

    Index.prototype.serialize = function() {
      var index;
      index = {
        table: this.table.name,
        name: this.name
      };
      if (this.reference) {
        index.reference = this.reference;
      }
      if (this.primary) {
        index.primary = this.columns;
      } else if (this.unique) {
        index.unique = this.columns;
      } else {
        index.index = this.columns;
      }
      return index;
    };

    Index.prototype.referenceQuery = function(keyvals) {
      var col, i, obj, _i, _len, _ref1;
      if (!this.reference) {
        throw new Error("Index.referenceQuery:not_a_foreign_key: " + this.name);
      }
      obj = {};
      _ref1 = this.reference.columns;
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        col = _ref1[i];
        if (keyvals.hasOwnProperty(col)) {
          obj[this.columns[i]] = keyvals[col];
        }
      }
      return obj;
    };

    Index.prototype.reverseReferenceQuery = function(keyvals) {
      var col, i, obj, _i, _len, _ref1;
      if (!this.reference) {
        throw new Error("Index.referenceQuery:not_a_foreign_key: " + this.name);
      }
      obj = {};
      _ref1 = this.columns;
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        col = _ref1[i];
        if (keyvals.hasOwnProperty(col)) {
          obj[this.reference.columns[i]] = keyvals[col];
        }
      }
      return obj;
    };

    return Index;

  })();

  Table = (function() {

    function Table(schema, name, defs, mixin) {
      this.schema = schema;
      this.name = name;
      this.defs = defs;
      this.mixin = mixin;
      if (this.schema.hasTable(this.name)) {
        throw new Error("duplicate_table_in_schema: " + this.name + ", " + this.schema.name);
      }
      this.initColumns();
      this.initIndexes();
    }

    Table.prototype.destroy = function() {
      var index, key;
      delete this.schema;
      for (key in indexes) {
        index = indexes[key];
        index.destroy();
      }
      delete this.indexes;
      return this.columns.destroy();
    };

    Table.prototype.ensureColumnNames = function(columns) {
      var col, names, _i, _len, _results;
      names = {};
      _results = [];
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        if (names.hasOwnProperty(col.col)) {
          throw new Error("duplicate_column_in_table: " + col.col + ", " + this.table.name);
        } else if (names.hasOwnProperty(col.col.toLowerCase())) {
          throw new Error("duplicate_column_case_insensitive_in_table: " + col.col + ", " + this.table.name);
        } else {
          names[col.col] = col;
          _results.push(names[col.col.toLowerCase()] = col);
        }
      }
      return _results;
    };

    Table.prototype.extractColumns = function(defs) {
      return _.filter(defs, function(obj) {
        return obj.col || obj.column;
      });
    };

    Table.prototype.initColumns = function() {
      var col, columns;
      columns = this.extractColumns(this.defs);
      this.ensureColumnNames(columns);
      return this.columns = new Columns((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = columns.length; _i < _len; _i++) {
          col = columns[_i];
          _results.push(this.makeColumn(col));
        }
        return _results;
      }).call(this));
    };

    Table.prototype.makeColumn = function(col) {
      return new Column(this, col);
    };

    Table.prototype.extractIndexes = function(defs) {
      var helper;
      helper = function(def) {
        return def.index || def.primary || def.unique || def.reference;
      };
      return _.filter(defs, helper);
    };

    Table.prototype.initIndexes = function() {
      var def, index, indexDef, indexes, _i, _len, _results;
      this.indexes = {};
      indexes = this.extractIndexes(this.defs);
      _results = [];
      for (_i = 0, _len = indexes.length; _i < _len; _i++) {
        def = indexes[_i];
        indexDef = this.normalizeIndexDef(def);
        index = new Index(this, indexDef);
        _results.push(this.indexes[index.name] = index);
      }
      return _results;
    };

    Table.prototype.normalizeIndexDef = function(def) {
      var col;
      if (def.col) {
        col = def.primary ? {
          primary: [def.col]
        } : def.unique ? {
          unique: [def.col]
        } : {
          index: [def.col]
        };
        if (def.reference) {
          col.reference = def.reference;
        }
        if (def.name) {
          col.name = def.name;
        }
        return col;
      } else {
        return def;
      }
    };

    Table.prototype.hasColumn = function(col) {
      if (this.columns.hasOwnProperty(col)) {
        return this.columns[col];
      } else {
        return void 0;
      }
    };

    Table.prototype.hasPrimary = function() {
      return this.primary;
    };

    Table.prototype.setPrimary = function(index) {
      if (this.primary) {
        throw new Error("Table_cannot_have_multiple_primary_keys");
      }
      index.primary = true;
      return this.primary = index;
    };

    Table.prototype.hasUnique = function() {
      var index, key, _ref1;
      _ref1 = this.indexes;
      for (key in _ref1) {
        index = _ref1[key];
        if (index.unique) {
          return index;
        }
      }
      return void 0;
    };

    Table.prototype.hasPrimaryOrUnique = function() {
      if (this.hasPrimary()) {
        return this.primary;
      } else {
        return this.hasUnique();
      }
    };

    Table.prototype.references = function(table) {
      var index, key, _ref1, _ref2;
      _ref1 = this.indexes;
      for (key in _ref1) {
        index = _ref1[key];
        if (((_ref2 = index.reference) != null ? _ref2.table : void 0) === table.name) {
          return index;
        }
      }
      return void 0;
    };

    Table.prototype.serialize = function() {
      var col, _i, _len, _ref1, _results;
      _ref1 = this.columns;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        col = _ref1[_i];
        _results.push(col.serialize());
      }
      return _results;
    };

    Table.prototype.validate = function(val) {
      var col, _i, _len, _ref1, _results;
      _ref1 = this.columns;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        col = _ref1[_i];
        _results.push(col.validate(val[col.name]));
      }
      return _results;
    };

    Table.prototype.make = function(val) {
      var col, obj, type, _i, _len, _ref1;
      obj = {};
      _ref1 = this.columns;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        col = _ref1[_i];
        obj[col.name] = col.make(val[col.name]);
      }
      type = this.schema.hasType(this.name);
      if (type) {
        return type.make(obj);
      } else {
        return obj;
      }
    };

    Table.prototype.idQuery = function(query) {
      var index;
      index = this.hasPrimaryOrUnique();
      if (index) {
        return this._idQuery(index, query);
      } else {
        return query;
      }
    };

    Table.prototype._idQuery = function(index, query) {
      var col, obj, _i, _len, _ref1;
      obj = {};
      _ref1 = index.columns;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        col = _ref1[_i];
        obj[col] = query[col];
      }
      return obj;
    };

    Table.prototype.getRelationQuery = function(tableName, args, record) {
      var index, query, table;
      table = this.schema.hasTable(tableName);
      if (!table) {
        throw new Error("ActiveRecord.select:unknown_table: " + tableName);
      }
      index = table.references(this);
      if (index) {
        query = index.referenceQuery(record);
        return _.extend(query, args);
      } else {
        index = this.references(table);
        if (index) {
          query = index.reverseReferenceQuery(record);
          return _.extend(query, args);
        } else {
          throw new Error("ActiveRecord.select:tables_not_related: " + this.name + ", " + tableName);
        }
      }
    };

    Table.prototype.transpose = function(records) {
      var col, columns, helper, _i, _len, _ref1;
      columns = {};
      helper = function(col) {
        var data, rec, _i, _len;
        data = [];
        for (_i = 0, _len = records.length; _i < _len; _i++) {
          rec = records[_i];
          data.push(rec[col.name]);
        }
        return data;
      };
      _ref1 = this.columns;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        col = _ref1[_i];
        columns[col.name] = helper(col);
      }
      return columns;
    };

    return Table;

  })();

  ActiveRecord = (function(_super) {

    __extends(ActiveRecord, _super);

    function ActiveRecord(table, db, record) {
      this.table = table;
      this.db = db;
      console.log('ActiveRecord.ctor', this.table.name, record);
      this.record = this.db.normalizeRecord(this.table, record);
      this.changed = false;
      this.deleted = false;
      this.updated = {};
      _.extend(this, this.table.mixin);
    }

    ActiveRecord.prototype.set = function(key, val) {
      var column, i, obj, _i, _len, _ref1, _results;
      if (this.deleted) {
        throw new Error("ActiveRecord.set:record_already_deleted");
      }
      obj = arguments.length === 2 ? (obj = {}, obj[key] = val, obj) : key;
      for (key in obj) {
        val = obj[key];
        this._setOne(key, val);
      }
      _ref1 = this.table.columns;
      _results = [];
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        column = _ref1[i];
        if (column.update && !obj.hasOwnProperty(column.name)) {
          _results.push(this._setOne(column.name, column.update(this.record[column.name])));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ActiveRecord.prototype._setOne = function(key, val) {
      var col;
      col = this.table.hasColumn(key);
      if (col && !col.validate(val)) {
        throw new Error("" + table.name + "." + col.name + ":fail_validation: " + val);
      }
      this.updated[key] = val;
      return this.changed = true;
    };

    ActiveRecord.prototype.get = function(key) {
      if (this.deleted) {
        throw new Error("ActiveRecord.get:record_already_deleted");
      }
      if (this.updated.hasOwnProperty(key)) {
        return this.updated[key];
      } else if (this.record.hasOwnProperty(key)) {
        return this.record[key];
      } else {
        return void 0;
      }
    };

    ActiveRecord.prototype.select = function(tableName, args, cb) {
      var query;
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      try {
        query = this.table.getRelationQuery(tableName, args, this.record);
        return this.db.select(tableName, query, cb);
      } catch (e) {
        return cb(e);
      }
    };

    ActiveRecord.prototype.selectOne = function(tableName, args, cb) {
      var query;
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      try {
        query = this.table.getRelationQuery(tableName, args, this.record);
        return this.db.selectOne(tableName, query, cb);
      } catch (e) {
        return cb(e);
      }
    };

    ActiveRecord.prototype.insert = function(tableName, args, cb) {
      var index, query, table;
      table = this.table.schema.hasTable(tableName);
      if (!table) {
        return cb(new Error("ActiveRecord.selectOne:unknown_table: " + tableName));
      }
      index = table.references(this.table);
      if (index) {
        query = index.referenceQuery(this.record);
        args = _.extend({}, args, query);
        return this.db.insert(tableName, args, cb);
      } else {
        return cb(new Error("ActiveRecord.insert:tables_not_related: " + this.table.name + ", " + tableName));
      }
    };

    ActiveRecord.prototype.idQuery = function() {
      if (this.deleted) {
        throw new Error("ActiveRecord.idQuery:record_already_deleted");
      }
      return this.table.idQuery(this.record);
    };

    ActiveRecord.prototype.update = function(keyVals, cb) {
      if (this.deleted) {
        return cb(new Error("ActiveRecord.update:record_already_deleted"));
      }
      try {
        this.set(keyVals);
        return this.save(cb);
      } catch (e) {
        return cb(e);
      }
    };

    ActiveRecord.prototype.save = function(cb) {
      var query,
        _this = this;
      if (this.deleted) {
        return cb(new Error("ActiveRecord.save:record_already_deleted"));
      }
      if (this.changed) {
        query = this.db.generateUpdate(this.table, this.updated, this.idQuery());
        return this.db.query(query, {}, function(err, res) {
          if (err) {
            return cb(err);
          } else {
            _.extend(_this.record, _this.updated);
            _this.updated = {};
            _this.changed = false;
            return cb(null, _this);
          }
        });
      } else {
        return cb(null, this);
      }
    };

    ActiveRecord.prototype["delete"] = function(cb) {
      var query,
        _this = this;
      if (this.deleted) {
        return cb(new Error("ActiveRecord.delete:record_already_deleted"));
      }
      query = this.db.generateDelete(this.table, this.idQuery());
      return this.db.query(query, {}, function(err, res) {
        if (err) {
          return cb(err);
        } else {
          _this.deleted = true;
          return cb(null);
        }
      });
    };

    return ActiveRecord;

  })(EventEmitter);

  ActiveRecordSet = (function() {

    function ActiveRecordSet(table, db, records) {
      var record;
      this.table = table;
      this.db = db;
      this.records = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = records.length; _i < _len; _i++) {
          record = records[_i];
          _results.push(this.db.normalizeRecord(this.table, record));
        }
        return _results;
      }).call(this);
      this.length = this.records.length;
    }

    ActiveRecordSet.prototype.select = function(tableName, args, cb) {
      var helper, query, records, table,
        _this = this;
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      records = [];
      table = this.table.schema.hasTable(tableName);
      if (!table) {
        throw new Error("ActiveRecordSet.select:unknown_table: " + tableName);
      }
      helper = function(rec, next) {
        var active;
        active = new ActiveRecord(_this.table, _this.db, rec);
        return active.select(tableName(args, function(err, recs) {
          var _i, _len;
          if (err) {
            return next(err);
          } else {
            for (_i = 0, _len = recs.length; _i < _len; _i++) {
              rec = recs[_i];
              if (rec instanceof ActiveRecord) {
                records.push(rec.record);
              } else {
                records.push(rec);
              }
            }
            return next(null);
          }
        }));
      };
      if (this.db.supports('in')) {
        query = this.table.getRelationQuery(tableName, args, this.transpose());
        return this.select(tableName, query, function(err, records) {
          if (err) {
            return cb(err);
          } else {
            return cb(null, new ActiveRecordSet(table, _this.db, records));
          }
        });
      } else {
        return async.forEach(this.records, helper, function(err) {
          if (err) {
            return cb(err);
          } else {
            return cb(null, new ActiveRecordSet(table, _this.db, records));
          }
        });
      }
    };

    ActiveRecordSet.prototype.selectOne = function(tableName, args, cb) {
      var _this = this;
      return this.select(tableName, args, function(err, recordSet) {
        if (err) {
          return cb(err);
        } else if (recordSet.length > 1) {
          return cb(null, recordSet.first());
        } else {
          return cb(new Error("ActiveRecordSet.selectOne:record_not_found: " + tableName + ", " + (JSON.stringify(args))));
        }
      });
    };

    ActiveRecordSet.prototype["delete"] = function(cb) {
      var args, query;
      args = this.table.idQuery(this.transpose());
      console.log('ActiveRecordSet.delete', this.tableName, args);
      query = this.db.generateDelete(this.table, args);
      console.log('ActiveRecordSet.delete', query);
      return this.db.query(query, cb);
    };

    ActiveRecordSet.prototype.transpose = function() {
      return this.table.transpose(this.records);
    };

    ActiveRecordSet.prototype.first = function() {
      console.log('ActiveRecordSet.first()', this.table.name, this.records[0]);
      return new ActiveRecord(this.table, this.db, this.records[0]);
    };

    return ActiveRecordSet;

  })();

  Schema = (function() {

    Schema.builtInTypes = {};

    Schema.builtInFunctions = {};

    Schema.Record = ActiveRecord;

    Schema.RecordSet = ActiveRecordSet;

    Schema.registerType = function(name, type) {
      if (this.builtInTypes.hasOwnProperty(name)) {
        throw new Error("built_type_duplicate: " + name);
      }
      return this.builtInTypes[name] = type;
    };

    Schema.registerFunction = function(name, proc) {
      if (this.builtInFunctions.hasOwnProperty(name)) {
        throw new Error("builtin_function_duplicate: " + name);
      }
      return this.builtInFunctions[name] = proc;
    };

    function Schema(schema) {
      this.types = {};
      this.tables = {};
      this.indexes = {};
      this.references = {};
      this.functions = {};
      if (schema) {
        this.initialize(schema);
      }
    }

    Schema.prototype.destroy = function() {
      var index, key, table, _ref1, _ref2;
      _ref1 = this.indexes;
      for (key in _ref1) {
        index = _ref1[key];
        index.destroy();
      }
      delete this.indexes;
      _ref2 = this.tables;
      for (key in _ref2) {
        table = _ref2[key];
        table.destroy();
      }
      return delete this.tables;
    };

    Schema.prototype.initialize = function(schema) {
      var def, indexes, key, tables, val, _i, _len, _results;
      this.name = schema.name, tables = schema.tables, indexes = schema.indexes;
      if (tables) {
        for (key in tables) {
          val = tables[key];
          this.defineTable(key, val);
        }
      }
      if (indexes) {
        _results = [];
        for (_i = 0, _len = indexes.length; _i < _len; _i++) {
          def = indexes[_i];
          _results.push(this.defineIndex(def));
        }
        return _results;
      }
    };

    Schema.prototype.defineTable = function(name, defs, mixin) {
      var table;
      if (mixin == null) {
        mixin = {};
      }
      table = new Table(this, name, defs, mixin);
      return this.tables[table.name] = table;
    };

    Schema.prototype.defineIndex = function(def) {
      var table;
      if (!def.table) {
        throw new Error("index_requires_table: " + def);
      }
      table = this.hasTable(def.table);
      if (!table) {
        throw new Error("index_table_unknown: " + def.table);
      }
      return new Index(table, def);
    };

    Schema.prototype.registerFunction = function(name, proc) {
      if (this.functions.hasOwnProperty(name)) {
        throw new Error("function_duplicated: " + name);
      }
      return this.functions[name] = proc;
    };

    Schema.prototype.hasFunction = function(name) {
      if (this.functions.hasOwnProperty(name)) {
        return this.functions[name];
      } else if (this.constructor.builtInFunctions.hasOwnProperty(name)) {
        return this.constructor.builtInFunctions[name];
      } else {
        return void 0;
      }
    };

    Schema.prototype.registerType = function(name, type) {
      if (this.types.hasOwnProperty(name)) {
        throw new Error("duplicate_type: " + name);
      }
      return this.types[name] = type;
    };

    Schema.prototype.registerTableType = function(name, type) {
      if (!type.hasOwnProperty('spec')) {
        throw new Error("lack_of_table_spec: " + name);
      }
      if (!type.make) {
        type.make = function(obj) {
          return new type(obj);
        };
      }
      this.defineTable(name, type.spec);
      return this.registerType(name, type);
    };

    Schema.prototype.hasType = function(name) {
      if (this.types.hasOwnProperty(name)) {
        return this.types[name];
      } else if (this.constructor.builtInTypes.hasOwnProperty(name)) {
        return this.constructor.builtInTypes[name];
      } else {
        return void 0;
      }
    };

    Schema.prototype.registerIndex = function(index) {
      if (this.indexes.hasOwnProperty(index.name)) {
        throw new Error("index_name_duplication: " + index.name);
      }
      return this.indexes[index.name] = index;
    };

    Schema.prototype.registerReference = function(index, table, columns) {
      return this.references[index.name] = new Reference(this, index, table, columns);
    };

    Schema.prototype.hasTable = function(name) {
      if (this.tables.hasOwnProperty(name)) {
        return this.tables[name];
      } else {
        return void 0;
      }
    };

    Schema.prototype.makeRecord = function(db, tableName, arg) {
      var table;
      table = this.hasTable(tableName);
      if (!table) {
        throw new Error("Schema.makeRecord:invalid_table: " + tableName);
      }
      return new ActiveRecord(table, db, arg);
    };

    Schema.prototype.makeRecordSet = function(db, tableName, arg) {
      var table;
      table = this.hasTable(tableName);
      if (!table) {
        throw new Error("Schema.makeRecord:invalid_table: " + tableName);
      }
      return new ActiveRecordSet(table, db, arg);
    };

    Schema.prototype.serialize = function() {
      var index, indexes, key, table, tables, _ref1, _ref2;
      tables = {};
      _ref1 = this.tables;
      for (key in _ref1) {
        table = _ref1[key];
        tables[key] = table.serialize();
      }
      indexes = [];
      _ref2 = this.indexes;
      for (key in _ref2) {
        index = _ref2[key];
        indexes.push(index.serialize());
      }
      return {
        name: name,
        tables: tables,
        indexes: indexes
      };
    };

    return Schema;

  })();

  STRING = (function() {

    function STRING() {}

    STRING.make = function(val) {
      if (typeof val === 'string') {
        return val;
      } else if (val instanceof Object) {
        return JSON.stringify(val);
      } else {
        return "" + val;
      }
    };

    STRING.convertable = function(val) {
      return typeof val === 'string';
    };

    return STRING;

  })();

  Schema.registerType('string', STRING);

  UUID = (function() {

    function UUID() {}

    UUID.make = function(val) {
      if (this.convertable(val)) {
        return val;
      } else {
        return uuid.v4();
      }
    };

    UUID.convertable = function(val) {
      return val.match(/^[0-9a-fA-F]{8}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12}$/);
    };

    return UUID;

  })();

  Schema.registerType('uuid', UUID);

  NUMBER = (function() {

    function NUMBER() {}

    NUMBER.convertable = function(val) {
      return typeof val === 'number' || (typeof val === 'string' && val.match(/^-?\d*\.?\d*$/));
    };

    NUMBER.make = function(val) {
      if (typeof val === 'number') {
        return val;
      } else {
        return parseInt(val);
      }
    };

    return NUMBER;

  })();

  Schema.registerType('number', NUMBER);

  INTEGER = (function() {

    function INTEGER() {}

    INTEGER.convertable = function(val) {
      return (typeof val === 'number' && Math.round(val) === val) || (typeof val === 'string' && val.match(/^-?\d*/));
    };

    INTEGER.make = function(val) {
      if (this.convertable(val)) {
        if (typeof val === 'string') {
          return parseInt(val);
        } else {
          return val;
        }
      } else {
        throw new Error("invalid_integer: " + val);
      }
    };

    return INTEGER;

  })();

  Schema.registerType('integer', INTEGER);

  EMAIL = (function() {

    function EMAIL() {}

    EMAIL.convertable = function(val) {
      return check(val).isEmail();
    };

    EMAIL.make = function(val) {
      if (this.convertable(val)) {
        return val;
      } else {
        throw new Error("invalid_email: " + val);
      }
    };

    return EMAIL;

  })();

  Schema.registerType('email', EMAIL);

  HEXSTRING = (function() {

    function HEXSTRING() {}

    HEXSTRING.convertable = function(val) {
      return check(val).isHexadecimal(val);
    };

    HEXSTRING.make = function(val) {
      if (this.convertable(val)) {
        return val;
      } else {
        throw new Error("invalid_hexstring: " + val);
      }
    };

    return HEXSTRING;

  })();

  Schema.registerType('hexString', HEXSTRING);

  DATETIME = (function() {

    function DATETIME() {}

    DATETIME.convertable = function(val) {
      return check(val).isDate(val);
    };

    DATETIME.make = function(val) {
      if (this.convertable(val)) {
        return new Date(Date.parse(val));
      } else {
        throw new Error("invalid_datetime: " + val);
      }
    };

    return DATETIME;

  })();

  Schema.registerType('datetime', DATETIME);

  b2h = [];

  h2b = {};

  for (i = _i = 0; _i < 256; i = _i += 1) {
    b2h[i] = (i ^ 0x100).toString(16).substring(1);
    h2b[b2h[i]] = i;
  }

  toHex = function(bytes) {
    var byte, _j, _len, _results;
    _results = [];
    for (_j = 0, _len = bytes.length; _j < _len; _j++) {
      byte = bytes[_j];
      _results.push(b2h[byte]);
    }
    return _results;
  };

  Schema.registerFunction('randomBytes', function(size) {
    if (size == null) {
      size = 32;
    }
    return toHex(crypto.randomBytes(size)).join('');
  });

  Schema.registerFunction('makeUUID', uuid.v4);

  Schema.registerFunction('now', function() {
    return new Date();
  });

  Schema.registerFunction('increment', function(i) {
    if (i == null) {
      i = 0;
    }
    return i + 1;
  });

  module.exports = Schema;

}).call(this);
