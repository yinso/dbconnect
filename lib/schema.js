// Generated by CoffeeScript 1.4.0
(function() {
  var ActiveRecord, Column, Columns, EMAIL, EventEmitter, HEXSTRING, Index, NUMBER, Reference, STRING, Schema, Table, UUID, async, check, crypto, sanitize, uuid, _, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  _ = require('underscore');

  uuid = require('node-uuid');

  async = require('async');

  EventEmitter = require('events').EventEmitter;

  _ref = require('validator'), check = _ref.check, sanitize = _ref.sanitize;

  crypto = require('crypto');

  Column = (function() {

    function Column(table, def) {
      var col, optional, proc, schemaType, type, _ref1,
        _this = this;
      this.table = table;
      this.def = def;
      _ref1 = this.def, col = _ref1.col, type = _ref1.type, optional = _ref1.optional;
      this.name = col;
      schemaType = this.table.schema.hasType(type);
      if (!schemaType) {
        throw new Error("unknown_type: " + type);
      }
      this.type = schemaType;
      this.optional = optional || false;
      if (this.def["default"]) {
        if (this.def["default"] instanceof Object) {
          proc = this.table.schema.hasFunction(this.def["default"].proc);
          if (!proc) {
            throw new Error("unknown_default_function: " + this.def["default"].proc);
          }
          this["default"] = proc;
        } else {
          this["default"] = function(cb) {
            return _this.def["default"];
          };
        }
        this.optional = true;
      }
    }

    Column.prototype.destroy = function() {
      delete this.table;
      delete this.type;
      return delete this["default"];
    };

    Column.prototype.serialize = function() {
      return this.def;
    };

    Column.prototype.validate = function(val) {
      if (val !== void 0 && val !== null) {
        return this.type.convertable(val);
      } else if (this.optional) {
        return true;
      } else {
        throw new Error("value_required: " + this.table.name + "." + this.name);
      }
    };

    Column.prototype.make = function(val) {
      if (val !== void 0 && val !== null) {
        return this.type.make(val);
      } else if (this.optional) {
        if (this["default"]) {
          return this["default"]();
        } else {
          return null;
        }
      } else {
        throw new Error("value_required: " + this.table.name + "." + this.name);
      }
    };

    return Column;

  })();

  Columns = (function(_super) {

    __extends(Columns, _super);

    function Columns(columns) {
      var col, _i, _j, _len, _len1;
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        this.ensureColumn(col);
      }
      for (_j = 0, _len1 = columns.length; _j < _len1; _j++) {
        col = columns[_j];
        this.push(col);
        this[col.name] = col;
      }
    }

    Columns.prototype.destroy = function() {
      var key, val, _results;
      _results = [];
      for (key in this) {
        val = this[key];
        if (val instanceof Index) {
          _results.push(val.destroy());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Columns.prototype.ensureColumn = function(col) {
      if (!(col instanceof Column)) {
        throw new Error("columns.ctor:not_a_column: " + col);
      }
    };

    Columns.prototype.splice = function() {
      var col, index, inserted, removed, removedCols, _i, _j, _k, _len, _len1, _len2;
      index = arguments[0], removed = arguments[1], inserted = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      for (_i = 0, _len = inserted.length; _i < _len; _i++) {
        col = inserted[_i];
        this.ensureColumn(col);
      }
      removedCols = Columns.__super__.splice.apply(this, [index, removed].concat(__slice.call(inserted)));
      for (_j = 0, _len1 = removedCols.length; _j < _len1; _j++) {
        col = removedCols[_j];
        delete this[col.name];
      }
      for (_k = 0, _len2 = inserted.length; _k < _len2; _k++) {
        col = inserted[_k];
        this[col.name] = col;
      }
      return removedCols;
    };

    Columns.prototype.push = function() {
      var col;
      col = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.splice.apply(this, [this.length, 0].concat(__slice.call(col)));
    };

    Columns.prototype.pop = function() {
      var col, res;
      col = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      res = this.splice(this.length - 1, 1);
      return res[0];
    };

    Columns.prototype.unshift = function() {
      var col;
      col = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.splice.apply(this, [0, 0].concat(__slice.call(col)));
    };

    Columns.prototype.shift = function() {
      var res;
      res = this.splice(0, 1);
      return res[0];
    };

    return Columns;

  })(Array);

  Reference = (function() {

    function Reference(schema, index, table, columns) {
      this.schema = schema;
      this.index = index;
      this.table = table;
      this.columns = columns;
    }

    return Reference;

  })();

  Index = (function() {

    function Index(table, args) {
      var index, name, primary, reference, unique;
      this.table = table;
      index = args.index, primary = args.primary, unique = args.unique, name = args.name, reference = args.reference;
      if (primary) {
        this.init(primary, name);
        this.ensurePrimary();
      } else if (unique) {
        this.init(unique, name);
        this.ensureUnique();
      } else {
        this.init(index, name);
      }
      if (reference) {
        this.ensureReference(reference);
      }
    }

    Index.prototype.destroy = function() {
      return delete this.table;
    };

    Index.prototype.init = function(columns, name) {
      var col, _i, _len;
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        if (!this.table.hasColumn(col)) {
          throw new Error("unknown_column_in_table: " + col + ", " + this.table.name);
        }
      }
      this.columns = columns;
      this.name = (!name ? this.makeName() : name);
      return this.table.schema.registerIndex(this);
    };

    Index.prototype.makeName = function() {
      var columnName;
      columnName = this.columns.join('_');
      return "" + this.table.name + "_" + columnName;
    };

    Index.prototype.ensurePrimary = function() {
      return this.table.setPrimary(this);
    };

    Index.prototype.ensureUnique = function() {
      return this.unique = true;
    };

    Index.prototype.ensureReference = function(reference) {
      var col, columns, refTable, table, _i, _len, _ref1;
      this.reference = reference;
      _ref1 = this.reference, table = _ref1.table, columns = _ref1.columns;
      refTable = this.table.schema.hasTable(table);
      if (!refTable) {
        throw new Error("Unknown_reference_table: " + table);
      }
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        if (!refTable.hasColumn(col)) {
          throw new Error("unknown_reference_column: " + table + "." + col);
        }
      }
      return this.table.schema.registerReference(this, refTable, columns);
    };

    Index.prototype.serialize = function() {
      var index;
      index = {
        table: this.table.name,
        name: this.name
      };
      if (this.reference) {
        index.reference = this.reference;
      }
      if (this.primary) {
        index.primary = this.columns;
      } else if (this.unique) {
        index.unique = this.columns;
      } else {
        index.index = this.columns;
      }
      return index;
    };

    return Index;

  })();

  Table = (function() {

    function Table(schema, name, defs) {
      this.schema = schema;
      this.name = name;
      this.defs = defs;
      if (this.schema.hasTable(this.name)) {
        throw new Error("duplicate_table_in_schema: " + this.name + ", " + this.schema.name);
      }
      this.initColumns();
      this.initIndexes();
    }

    Table.prototype.destroy = function() {
      var index, key;
      delete this.schema;
      for (key in indexes) {
        index = indexes[key];
        index.destroy();
      }
      delete this.indexes;
      return this.columns.destroy();
    };

    Table.prototype.ensureColumnNames = function(columns) {
      var col, names, _i, _len, _results;
      names = {};
      _results = [];
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        if (names.hasOwnProperty(col.col)) {
          throw new Error("duplicate_column_in_table: " + col.col + ", " + this.table.name);
        } else {
          _results.push(names[col.col] = col);
        }
      }
      return _results;
    };

    Table.prototype.extractColumns = function(defs) {
      return _.filter(defs, function(obj) {
        return obj.col || obj.column;
      });
    };

    Table.prototype.initColumns = function() {
      var col, columns;
      columns = this.extractColumns(this.defs);
      this.ensureColumnNames(columns);
      return this.columns = new Columns((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = columns.length; _i < _len; _i++) {
          col = columns[_i];
          _results.push(this.makeColumn(col));
        }
        return _results;
      }).call(this));
    };

    Table.prototype.makeColumn = function(col) {
      return new Column(this, col);
    };

    Table.prototype.extractIndexes = function(defs) {
      var helper;
      helper = function(def) {
        return def.index || def.primary || def.unique || def.reference;
      };
      return _.filter(defs, helper);
    };

    Table.prototype.initIndexes = function() {
      var def, index, indexDef, indexes, _i, _len, _results;
      this.indexes = {};
      indexes = this.extractIndexes(this.defs);
      _results = [];
      for (_i = 0, _len = indexes.length; _i < _len; _i++) {
        def = indexes[_i];
        indexDef = this.normalizeIndexDef(def);
        index = new Index(this, indexDef);
        _results.push(this.indexes[index.name] = index);
      }
      return _results;
    };

    Table.prototype.normalizeIndexDef = function(def) {
      var col;
      if (def.col) {
        col = def.primary ? {
          primary: [def.col]
        } : def.unique ? {
          unique: [def.col]
        } : {
          index: [def.col]
        };
        if (def.reference) {
          col.reference = def.reference;
        }
        if (def.name) {
          col.name = def.name;
        }
        return col;
      } else {
        return def;
      }
    };

    Table.prototype.hasColumn = function(col) {
      if (this.columns.hasOwnProperty(col)) {
        return this.columns[col];
      } else {
        return void 0;
      }
    };

    Table.prototype.hasPrimary = function() {
      return this.primary;
    };

    Table.prototype.setPrimary = function(index) {
      if (this.primary) {
        throw new Error("Table_cannot_have_multiple_primary_keys");
      }
      index.primary = true;
      return this.primary = index;
    };

    Table.prototype.hasUnique = function() {
      var index, key, _ref1;
      _ref1 = this.indexes;
      for (key in _ref1) {
        index = _ref1[key];
        if (index.unique) {
          return index;
        }
      }
      return void 0;
    };

    Table.prototype.serialize = function() {
      var col, _i, _len, _ref1, _results;
      _ref1 = this.columns;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        col = _ref1[_i];
        _results.push(col.serialize());
      }
      return _results;
    };

    Table.prototype.validate = function(val) {
      var col, _i, _len, _ref1, _results;
      _ref1 = this.columns;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        col = _ref1[_i];
        _results.push(col.validate(val[col.name]));
      }
      return _results;
    };

    Table.prototype.make = function(val) {
      var col, obj, type, _i, _len, _ref1;
      obj = {};
      _ref1 = this.columns;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        col = _ref1[_i];
        obj[col.name] = col.make(val[col.name]);
      }
      type = this.schema.hasType(this.name);
      if (type) {
        return type.make(obj);
      } else {
        return obj;
      }
    };

    return Table;

  })();

  ActiveRecord = (function(_super) {

    __extends(ActiveRecord, _super);

    function ActiveRecord(table, db, record) {
      this.table = table;
      this.db = db;
      this.record = record;
      this.changed = false;
      this.deleted = false;
      this.updated = {};
    }

    ActiveRecord.prototype.set = function(key, val) {
      var k, v, _results;
      if (this.deleted) {
        throw new Error("ActiveRecord.set:record_already_deleted");
      }
      if (arguments.length === 2) {
        return this._setOne(key, val);
      } else if (arguments[0] instanceof Object) {
        _results = [];
        for (k in key) {
          v = key[k];
          _results.push(this._setOne(k, v));
        }
        return _results;
      } else {
        throw new Error("ActiveRecord.set:invalid_args: " + key + ", " + val);
      }
    };

    ActiveRecord.prototype._setOne = function(key, val) {
      var col;
      col = this.table.hasColumn(key);
      if (col && !col.validate(val)) {
        throw new Error("" + table.name + "." + col.name + ":fail_validation: " + val);
      }
      this.updated[key] = val;
      return this.changed = true;
    };

    ActiveRecord.prototype.get = function(key) {
      if (this.deleted) {
        throw new Error("ActiveRecord.get:record_already_deleted");
      }
      if (this.updated.hasOwnProperty(key)) {
        return this.updated[key];
      } else if (this.record.hasOwnProperty(key)) {
        return this.record[key];
      } else {
        return void 0;
      }
    };

    ActiveRecord.prototype.idQuery = function() {
      var primary, unique;
      if (this.deleted) {
        throw new Error("ActiveRecord.idQuery:record_already_deleted");
      }
      primary = this.table.hasPrimary();
      if (primary) {
        return this._idQuery(primary);
      } else {
        unique = this.table.hasUnique();
        if (unique) {
          return this._idQuery(unique);
        } else {
          return this.record;
        }
      }
    };

    ActiveRecord.prototype._idQuery = function(index) {
      var col, obj, _i, _len, _ref1;
      obj = {};
      _ref1 = index.columns;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        col = _ref1[_i];
        obj[col] = this.record[col];
      }
      return obj;
    };

    ActiveRecord.prototype.update = function(keyVals, cb) {
      if (this.deleted) {
        return cb(new Error("ActiveRecord.update:record_already_deleted"));
      }
      try {
        this.set(keyVals);
        return this.save(cb);
      } catch (e) {
        return cb(e);
      }
    };

    ActiveRecord.prototype.save = function(cb) {
      var query,
        _this = this;
      if (this.deleted) {
        return cb(new Error("ActiveRecord.save:record_already_deleted"));
      }
      if (this.changed) {
        query = this.db.generateUpdate(this.table, this.updated, this.idQuery());
        return this.db.query(query, {}, function(err, res) {
          if (err) {
            return cb(err);
          } else {
            _.extend(_this.record, _this.updated);
            _this.updated = {};
            _this.changed = false;
            return cb(null, _this);
          }
        });
      } else {
        return cb(null, this);
      }
    };

    ActiveRecord.prototype["delete"] = function(cb) {
      var query,
        _this = this;
      if (this.deleted) {
        return cb(new Error("ActiveRecord.delete:record_already_deleted"));
      }
      query = this.db.generateDelete(this.table, this.idQuery());
      return this.db.query(query, {}, function(err, res) {
        if (err) {
          return cb(err);
        } else {
          _this.deleted = true;
          return cb(null);
        }
      });
    };

    return ActiveRecord;

  })(EventEmitter);

  Schema = (function() {

    Schema.builtInTypes = {};

    Schema.builtInFunctions = {};

    Schema.Record = ActiveRecord;

    Schema.registerType = function(name, type) {
      if (this.builtInTypes.hasOwnProperty(name)) {
        throw new Error("built_type_duplicate: " + name);
      }
      return this.builtInTypes[name] = type;
    };

    Schema.registerFunction = function(name, proc) {
      if (this.builtInFunctions.hasOwnProperty(name)) {
        throw new Error("builtin_function_duplicate: " + name);
      }
      return this.builtInFunctions[name] = proc;
    };

    function Schema(schema) {
      this.types = {};
      this.tables = {};
      this.indexes = {};
      this.references = {};
      this.functions = {};
      if (schema) {
        this.initialize(schema);
      }
    }

    Schema.prototype.destroy = function() {
      var index, key, table, _ref1, _ref2;
      _ref1 = this.indexes;
      for (key in _ref1) {
        index = _ref1[key];
        index.destroy();
      }
      delete this.indexes;
      _ref2 = this.tables;
      for (key in _ref2) {
        table = _ref2[key];
        table.destroy();
      }
      return delete this.tables;
    };

    Schema.prototype.initialize = function(schema) {
      var def, indexes, key, tables, val, _i, _len, _results;
      this.name = schema.name, tables = schema.tables, indexes = schema.indexes;
      if (tables) {
        for (key in tables) {
          val = tables[key];
          this.defineTable(key, val);
        }
      }
      if (indexes) {
        _results = [];
        for (_i = 0, _len = indexes.length; _i < _len; _i++) {
          def = indexes[_i];
          _results.push(this.defineIndex(def));
        }
        return _results;
      }
    };

    Schema.prototype.defineTable = function(name, defs) {
      var table;
      table = new Table(this, name, defs);
      return this.tables[table.name] = table;
    };

    Schema.prototype.defineIndex = function(def) {
      var table;
      if (!def.table) {
        throw new Error("index_requires_table: " + def);
      }
      table = this.hasTable(def.table);
      if (!table) {
        throw new Error("index_table_unknown: " + def.table);
      }
      return new Index(table, def);
    };

    Schema.prototype.registerFunction = function(name, proc) {
      if (this.functions.hasOwnProperty(name)) {
        throw new Error("function_duplicated: " + name);
      }
      return this.functions[name] = proc;
    };

    Schema.prototype.hasFunction = function(name) {
      if (this.functions.hasOwnProperty(name)) {
        return this.functions[name];
      } else if (this.constructor.builtInFunctions.hasOwnProperty(name)) {
        return this.constructor.builtInFunctions[name];
      } else {
        return void 0;
      }
    };

    Schema.prototype.registerType = function(name, type) {
      if (this.types.hasOwnProperty(name)) {
        throw new Error("duplicate_type: " + name);
      }
      return this.types[name] = type;
    };

    Schema.prototype.registerTableType = function(name, type) {
      if (!type.hasOwnProperty('spec')) {
        throw new Error("lack_of_table_spec: " + name);
      }
      if (!type.make) {
        type.make = function(obj) {
          return new type(obj);
        };
      }
      this.defineTable(name, type.spec);
      return this.registerType(name, type);
    };

    Schema.prototype.hasType = function(name) {
      if (this.types.hasOwnProperty(name)) {
        return this.types[name];
      } else if (this.constructor.builtInTypes.hasOwnProperty(name)) {
        return this.constructor.builtInTypes[name];
      } else {
        return void 0;
      }
    };

    Schema.prototype.registerIndex = function(index) {
      if (this.indexes.hasOwnProperty(index.name)) {
        throw new Error("index_name_duplication: " + index.name);
      }
      return this.indexes[index.name] = index;
    };

    Schema.prototype.registerReference = function(index, table, columns) {
      return this.references[index.name] = new Reference(this, index, table, columns);
    };

    Schema.prototype.hasTable = function(name) {
      if (this.tables.hasOwnProperty(name)) {
        return this.tables[name];
      } else {
        return void 0;
      }
    };

    Schema.prototype.makeRecord = function(db, tableName, arg) {
      var table;
      table = this.hasTable(tableName);
      if (!table) {
        throw new Error("Schema.makeRecord:invalid_table: " + tableName);
      }
      return new ActiveRecord(table, db, arg);
    };

    Schema.prototype.serialize = function() {
      var index, indexes, key, table, tables, _ref1, _ref2;
      tables = {};
      _ref1 = this.tables;
      for (key in _ref1) {
        table = _ref1[key];
        tables[key] = table.serialize();
      }
      indexes = [];
      _ref2 = this.indexes;
      for (key in _ref2) {
        index = _ref2[key];
        indexes.push(index.serialize());
      }
      return {
        name: name,
        tables: tables,
        indexes: indexes
      };
    };

    return Schema;

  })();

  STRING = (function() {

    function STRING() {}

    STRING.make = function(val) {
      if (typeof val === 'string') {
        return val;
      } else if (val instanceof Object) {
        return JSON.stringify(val);
      } else {
        return "" + val;
      }
    };

    STRING.convertable = function(val) {
      return typeof val === 'string';
    };

    return STRING;

  })();

  Schema.registerType('string', STRING);

  UUID = (function() {

    function UUID() {}

    UUID.make = function(val) {
      if (this.convertable(val)) {
        return val;
      } else {
        return uuid.v4();
      }
    };

    UUID.convertable = function(val) {
      return val.match(/^[0-9a-fA-F]{8}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12}$/);
    };

    return UUID;

  })();

  Schema.registerType('uuid', UUID);

  NUMBER = (function() {

    function NUMBER() {}

    NUMBER.convertable = function(val) {
      return typeof val === 'number' || (typeof val === 'string' && val.match(/^-?\d*\.?\d*$/));
    };

    NUMBER.make = function(val) {
      if (typeof val === 'number') {
        return val;
      } else {
        return parseInt(val);
      }
    };

    return NUMBER;

  })();

  Schema.registerType('number', NUMBER);

  EMAIL = (function() {

    function EMAIL() {}

    EMAIL.convertable = function(val) {
      return check(val).isEmail();
    };

    EMAIL.make = function(val) {
      if (this.convertable(val)) {
        return val;
      } else {
        throw new Error("invalid_email: " + val);
      }
    };

    return EMAIL;

  })();

  Schema.registerType('email', EMAIL);

  HEXSTRING = (function() {

    function HEXSTRING() {}

    HEXSTRING.convertable = function(val) {
      return check(val).isHexdecimal(val);
    };

    HEXSTRING.make = function(val) {
      if (this.convertable(val)) {
        return val;
      } else {
        throw new Error("invalid_hexstring: " + val);
      }
    };

    return HEXSTRING;

  })();

  Schema.registerType('hexString', HEXSTRING);

  Schema.registerFunction('randomBytes', function(size) {
    var b2h, h2b, i, toHex, _i;
    if (size == null) {
      size = 32;
    }
    b2h = [];
    h2b = {};
    for (i = _i = 0; _i < 256; i = _i += 1) {
      b2h[i] = (i ^ 0x100).toString(16).substring(1);
      h2b[b2h[i]] = i;
    }
    toHex = function(bytes) {
      var byte, _j, _len, _results;
      _results = [];
      for (_j = 0, _len = bytes.length; _j < _len; _j++) {
        byte = bytes[_j];
        _results.push(b2h[byte]);
      }
      return _results;
    };
    return toHex(crypto.randomBytes(size)).join('');
  });

  module.exports = Schema;

}).call(this);
